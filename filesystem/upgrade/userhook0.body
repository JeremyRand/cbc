#!/bin/sh

#upgrade

# Print commands and their arguments as executed
set -x

if echo $0 | grep userhook0 > /dev/null; then
    # Being called from Botball boot script
    SELF=`echo $0`
    SUBHOOK=1
else
    # Being called from normal chumby bootup (/etc/init.d/rcS) must be on /mnt/usb
    SELF=/mnt/usb/userhook0
    SUBHOOK=0
fi

ROOT=${SELF%/userhook0}
cd $ROOT

# check if the KISS rcS startup file exists
if [ -e /psp ]; then
  # yes we're on a chumby
  if [ ! -e /psp/rfs1/rcS ]; then
    mkdir -p /psp/rfs1

    # unpack the KISS rcS startup file
    $EXTRACT_rcS >/psp/rfs1/rcS
    # unpack the frame buffer print character writer
    $EXTRACT_fb_print >/psp/rfs1/fb_print

    # make them executable
    chmod +x /psp/rfs1/rcS
    chmod +x /psp/rfs1/fb_print
    PRINT="/psp/rfs1/fb_print --echo"
    echo "Boot scripts updated...rebooting in 3 seconds" | $PRINT
    sleep 2
    sync
    sync
    reboot
  fi
fi

PRINT="/psp/rfs1/fb_print --echo"

if [ "$SUBHOOK" = "1" ]; then
  if [ "$1" = "--version" ]; then
    echo $VERSION
    exit 0
  elif [ "$1" = "--type" ]; then
    echo Upgrade
    exit 0
  elif [ "$1" = "--extract" ]; then
    echo Extract
    $EXTRACT_fdisk       >fdisk
    $EXTRACT_mkfs_ext2   >mkfs.ext2
    $EXTRACT_rcS         >rcS
    $EXTRACT_fb_print    >fb_print
    $EXTRACT_ext2_ko     >ext2.ko
    $EXTRACT_ext2_tgz    >ext2.tgz
    exit 0
  elif [ "$1" = "--upgrade" ]; then
    INTERNAL_DEVICE=$2
    if [ ! -b /dev/${INTERNAL_DEVICE} ]; then
      echo "Incorrect option passed to --upgrade" | $PRINT
      exit 1
    else
      echo "Upgrade requested" | $PRINT
    fi
  fi
fi

# clear screen
echo -n ""| $PRINT 
echo "***************************************" | $PRINT
echo "* UPDATING FIRMWARE TO $VERSION          *" | $PRINT
echo "* THIS WILL TAKE SEVERAL MINUTES      *" | $PRINT
echo "* PLEASE PLUG IN YOUR POWER ADAPTER   *" | $PRINT
echo "* AND KEEP POWER ON                   *" | $PRINT
echo "***************************************" | $PRINT
sleep 10

# tell fb_print to skip the top 72 pixels
PRINT="$PRINT --skiptop 72"

# clear screen
echo -n ""| $PRINT 

# unpack the ext2 filesystem kernel module so mounting is possible
$EXTRACT_ext2_ko >/tmp/ext2.ko
# install the module
insmod /tmp/ext2.ko

###############################################
# save user data
echo -n "Backing up user data..." | $PRINT
USER=/mnt/user
USER_DEV=/dev/${INTERNAL_DEVICE}3
mkdir -p $USER
mount $USER_DEV $USER -t ext2
mkdir -p /mnt/usb/cbc_backup/user/
cp -a -f $USER/* /mnt/usb/cbc_backup/user/
sync
sync
umount $USER
echo "done." | $PRINT

###############################################
# Check the partition table...
PARTITION_COUNT=`cat /proc/partitions | grep ${INTERNAL_DEVICE} | wc -l`
echo -n "Checking partition table..." | $PRINT

# the internal USB flash stick has 2 partitions
# the first contains all KISS system files
# the second is for the users code
if [ "$PARTITION_COUNT" != "2" ]; then
  echo -n "updating..." | $PRINT

    # extract the fdisk program for partition creation
    $EXTRACT_fdisk >/tmp/fdisk
    chmod +x /tmp/fdisk

    # The following formats the two partitions
    # d1 d1 d1                  - deletes the existing partitions
    # n p 1 {default} 128M      - creates the first part. with default start to 128Mb size
    # n p 2 {default} {default} - creates the second part. with default (@ end of 128) to default or end of disk
    # w                         - writes and saves the partition table
/tmp/fdisk /dev/${INTERNAL_DEVICE} <<FDISKINPUT
d
1
d
1
d
1
n
p
1

128M
n
p
2


w

FDISKINPUT

  PARTITION_COUNT=`cat /proc/partitions | grep ${INTERNAL_DEVICE} | wc -l`
  if [ "$PARTITION_COUNT" != "2" ]; then
    echo "FAILD!" | $PRINT
    echo "" | $PRINT
    echo "You probably have a bad internal flash drive, call KIPR for support" | $PRINT
    exit 1
  fi
fi

echo "done." | $PRINT

##############################################
# Make the Filesystem
ln -s /proc/mounts /psp/mtab

KISS_DEV=/dev/${INTERNAL_DEVICE}1
USER_DEV=/dev/${INTERNAL_DEVICE}2

$EXTRACT_mkfs_ext2 >/tmp/mkfs.ext2
chmod +x /tmp/mkfs.ext2

echo -n "Creating ext2 partition on $KISS_DEV..." | $PRINT
/tmp/mkfs.ext2 $KISS_DEV
if [ "$?" != "0" ]; then
  echo "failed!" | $PRINT
  exit 1
fi
echo "done." | $PRINT

echo -n "Creating ext2 partition on $USER_DEV..." | $PRINT
/tmp/mkfs.ext2 $USER_DEV
if [ "$?" != "0" ]; then
  echo "failed!" | $PRINT
  exit 1
fi
echo "done." | $PRINT

###############################################
# add files to the new file systems
KISS=/mnt/kiss
USER=/mnt/user

# make the Kiss system directory
mkdir -p $KISS
# make the users code directory
mkdir -p $USER/code

# mount the filesystems
mount $KISS_DEV $KISS -t ext2 
mount $USER_DEV $USER -t ext2 

df $KISS_DEV $USER_DEV | $PRINT
$EXTRACT_ext2_tgz | tar -xvzf - -C $KISS | $PRINT
sync
sync
df $KISS_DEV $USER_DEV | $PRINT

################################################
# rewrite the rcS file
echo -n "Updating boot scripts..." | $PRINT
cp -f $KISS/rcS /psp/rfs1
echo "done." | $PRINT

################################################
# Restore user data
echo -n "Restoring user data..." | $PRINT
cp -a -f /mnt/usb/cbc_backup/user/* $USER/code
rm -rf /mnt/usb/cbc_backup
echo "done." | $PRINT

echo "Sync'ing drives..." | $PRINT
sync
sync

umount $KISS
umount $USER

################################################
# a new userhook has been installed from the gui
if [ "/mnt/usb" == "$ROOT" ]; then
# Updating finished, clear the screen and tell the user to power cycle the CBC
    PRINT="/tmp/fb_print --echo"
    echo -n "" | $PRINT
    echo " " | $PRINT
    echo "Updating CBC firmware complete!" | $PRINT
    echo " " | $PRINT
    echo "Please turn off the CBC and unplug the USB stick." | $PRINT
else
    echo "Rebooting!" | $PRINT
    sleep 1
    reboot
fi

exit 0
